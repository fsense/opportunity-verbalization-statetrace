polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(10:145,44))
p<-c(25)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='darkgreen',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(150:200,14))
p<-c(30)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(1:200,49))
p<-c(25)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='lightgreen',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(1:100,49))
p<-c(18)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(1:200,30))
p<-c(13)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='darkgreen',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(1:100,30))
p<-c(9)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='lightgreen',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
p<-c(3)
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
k<-c(sample(1:100,10))
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
for(i in p){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in k){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='darkgreen',lty=7,border='black')
}
}
for(i in p){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in k){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
}
treeloop()
##Draw Tree
treex2<-c(190,180,170,120,130,110,115)
treex<-c(155,165,175,145,135,140,160)
treey<-c(15)
treex3<-c(15,16,20,25,30)
treey3<-c(129)
## To draw a tree to a specific location, use drawTreeTorso function which runs both
## tree function and torso function. y=i, x=j
##
drawTree<-function(i,j){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
return(polygon(cord.a,cord.b,col='darkgreen',lty=7,border='black'))
}
drawTreeTorso<-function(i,j){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
drawTree(i,j)
return(polygon(cord.c,cord.d,col='brown',lty=10))
}
drawTreeTorso(130,25)
drawTreeTorso(131,30)
drawTreeTorso(132,20)
## Tree drawing loops, 3 kinds for each color. x must be a vector(treex) and y must be scalar (treey).
##
for(i in treey){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in treex){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='lightgreen',lty=7,border='black')
}
}
for(i in treey){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in treex){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
for(i in treey){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in treex2){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='green',lty=7,border='black')
}
}
for(i in treey){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in treex2){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
for(i in treey3){
cord.b<-c(i,i+2,i+3,i+4,i+5,i+6,i+8,i+15,i+8,i+6,i+5,i+4,i+3,i+2,i)
for(j in treex3){
cord.a<-c(j,j-1,j-2,j-3,j-4,j-4,j-2,j,j+2,j+4,j+4,j+3,j+2,j+1,j)
polygon(cord.a,cord.b,col='darkgreen',lty=7,border='black')
}
}
for(i in treey3){
cord.d<-c(i-5,i-4,i-3,i-2,i-1,i,i,i-1,i-2,i-3,i-4,i-5)
for(j in treex3){
cord.c<-c(j-1,j-1,j-1,j-1,j-1,j,j+1,j+2,j+2,j+2,j+2,j+2)
polygon(cord.c,cord.d,col='brown',lty=10)
}
}
##Draw boat I used : x=155, y=75
drawBoat<-function(x,y){
polygon(c(x-7, x, x+15), c(y+15, y, y+17), col='grey')#Torso
polygon(c(x-3, x+1, x+10), c(y+19, y+35, y+15), col='red') #Sail
}
drawBoat(155,75)
## Draw bird. I used (x,y)=(148,150),(140,145),(150,142)
drawBird<-function(x,y){
points(x=x, y=y, pch="^") #left wing
points(x=x+2, y=y, pch="^") # right wing
}
drawBird(150,142)
drawBird(140,145)
drawBird(148,150)
## drawLightHouse function- Define middle top point of the light house (x,y)
## I used( 131,80)
drawLightHouse<-function(x,y){
polygon(c((x-5):(x+5)), c(y-30,y-20,y-10,y,y,y,y,y,y-10,y-20,y-30), col='grey')#Torso
symbols(x=x, y = y+5, circles=5, inches = FALSE, add = TRUE, fg = "black", bg = 'lightblue')
symbols(x=x+2, y = y+5, circles=3, inches = FALSE, add = TRUE, fg = "green", bg = 'lightyellow')
points(x=x, y=y-10, pch="_",col='red')
points(x=x+1, y=y-10, pch="_",col='red')
points(x=x-1, y=y-15, pch="_",col='red')
points(x=x+1, y=y-15, pch="_",col='red')
points(x=x+2, y=y-15, pch="_",col='red')
}
drawLightHouse(131,80)
### Draw Wave loop
k<-c(105 , 100 , 91, 85 , 77, 68 ,102,60 , 75 ,115 , 110, 85, 55, 103)
wave<-c(130, 145, 180, 190, 170, 195, 194 , 190, 170 , 124, 140, 148 , 148, 120)
points (wave, k , col= 'blue', pch= "~")
## Sunshine waves
sunwavex<-c( 167, 170, 172, 175)
sunwavey <- c(119, 117, 119, 118)
points (sunwavex, sunwavey , col= 'orange', pch= "~")
sunwavek <- c(165,168,174,170)
sunwavem<- c(110,109,106,111)
points (sunwavek, sunwavem , col= 'orange', pch= "~")
sunwaves<-c(158, 159, 180,178)
sunwaven<-c(118, 110, 115, 119)
points (sunwaves, sunwaven , col= 'yellow', pch= "~")
###Cloud
cloudcord.x<-c(105,106,106,106,107,108,109,109,110,110,111,111,112,113,114,114,115,115,116,116,116,117,116,115,114,113,112,111,110,109,107,105)
cloudcord.y<-c(170,172,174,177,179,182,183,184,185,185,184,183,182,180,179,178,176,175,174,172,171,170,169,170,169,170,167,169, 168,170,169,170)
polygon(cloudcord.x,cloudcord.y, col='grey')
points(cloudcord.x,cloudcord.y, col='white', pch="O")
library("BayesFactor")
BFManual()
a <- rnorm(50)
hist(a)
a <- rnorm(150)
hist(a)
?rnorm
b <- rnorm(150, mean=2)
hist(b)
t.test(a, b)
b <- rnorm(150, mean=1)
t.test(a, b)
t.test(a)
x <- rnorm(50)
t.test(x)
ttestBF(x)
bf <- ttestBF(x)
str(bf)
1/bf
bf
1/bf
?ttestBF
x2 <- rnorm(50, mean=1)
t.test(x, x2)
bf2 <- ttestBF(x, x2)
bf2
bf2 <- ttestBF(x, x2)
bf2
plot(bf)
data(puzzles)
BFManual()
library("BayesFactor")
data(puzzles)
head(puzzles)
table(puzzles$shape)
bf3 <- anovaBF(RT ~ shape * color + ID, data=puzzles, whichRandom = "ID")
bf3
head(puzzles)
max(bf3)
plot(bf3)
summary(aov(RT ~ shape*color + Error(ID/shape*color), data=puzzles))
head(bf3)
head(bf3, 2)
which.max(bf3)
A <- read.table('mean_alphas.txt')
install.packages("lme4")
install.packages("zoo")
install.packages("lmtest")
install.packages("xtable")
library('xtable')
setwd("~/Dropbox/statetrace/paper/supplement")
source('intNormal.R') # for approximation to integral
# source('http://openmx.psyc.virginia.edu/getOpenMx.R')
library('OpenMx')
library('gtools')
library('xtable')
plotRestricted = TRUE
loadSamples = TRUE
rand.seed = 595
set.seed(rand.seed)
loadSamples = loadSamples * plotRestricted
data <- read.csv("combined_dataset.csv", stringsAsFactors = FALSE)
data$silent = factor(data$silent)
levels(data$silent) = c("articulate","silent")
data$sequential = factor(data$sequential)
levels(data$sequential) = c("simultaneous","sequential")
data$change = factor(data$change)
levels(data$change) = c("same","change")
data$subjNumber = factor(data$subjNumber)
data$setSize = factor(data$setSize)
data$blocknum = ((data$session-1)*504 + (data$trial-1))%/%252 + 1
# What proportion of trials?
mean(is.na(data$RT))
data = data[!is.na(data$RT),]
1-mean(data$RT>200 & data$RT<3000) # What proportion of trials?
data = data[data$RT>200 & data$RT<3000, ]
# Correct trials for all combinations of conditions and participants
corrects = tapply(data$CResp,list(data$subjNumber,data$setSize,data$silent,data$sequential,data$change),sum)
# Total number of trials
Ntotal = table(data$subjNumber,data$setSize,data$silent,data$sequential,data$change)
# Convert tables to data frames for convenience
correctsDF = as.data.frame.table(corrects)
NtotalDF = as.data.frame.table(Ntotal)
# Check to make sure they line up
if(  all(correctsDF[,1:5] == NtotalDF[,1:5]) ){
correctsDF$N = NtotalDF$Freq
colnames(correctsDF) = c("sub","ss","art","seq","chg","cor","N")
}else{
stop("Could not merge data sets.")
}
# Compute estimates of probabilities and corresponding standard errors
correctsDF$phat = (correctsDF$cor + 1) / (correctsDF$N + 2)
correctsDF$stdErr = sqrt(correctsDF$phat * (1 - correctsDF$phat) / (correctsDF$N + 2))
chg = correctsDF[correctsDF$chg=="change",]
sme = correctsDF[correctsDF$chg=="same",]
# Check to make sure they line up
if(  all(sme[,1:4] == chg[,1:4]) ){
combinedDat = sme[,1:4]
# hits minus false alarms
combinedDat$d = chg$phat + sme$phat - 1
combinedDat$stdErr = sqrt(sme$stdErr^2 + chg$stdErr^2)
}else{
stop("Could not merge same and change.")
}
chg.mns = with(chg,tapply(phat, list(ss, art, seq), mean))
chg.sds = with(chg,tapply(phat, list(ss, art, seq), sd))
sme.mns = 1-with(sme,tapply(phat, list(ss, art, seq), mean))
sme.sds = with(sme,tapply(phat, list(ss, art, seq), sd))
table1 <- xtable(chg.mns - sme.mns, caption="Descriptive statistisc for d across all conditions.")
chg.mns - sme.mns
table1 <- xtable(chg.mns - sme.mns)
tmp <- chg.mns - sme.mns
str(tmp)
?as.data.frame
xtable(as.data.frame(tmp))
table1 <- xtable(as.data.frame(chg.mns - sme.mns), caption="Mean estimates of d across all conditions.")
print(table1)
table1 <- xtable(as.data.frame(chg.mns - sme.mns), caption="Mean estimates of d across all conditions.", label="tab:descriptiveStats")
print(table1)
summary(tmp)
chg.mns
as.data.frame(chg.msn)
as.data.frame(chg.mns)
as.data.frame(sme.mns)
cbind( as.data.frame(chg.mns), as.data.frame(sme.mns) )
tbl.data <- cbind( as.data.frame(chg.mns), as.data.frame(sme.mns) )
table1 <- xtable(tbl.data, caption="Mean estimates of d across all participants.", label="tab:descriptiveStats")
print(table1) # produces the LaTeX syntax for the table used in the paper.
par(mfrow = c( 1, 2), las=1)
for(cond in c('simultaneous', 'sequential')) {
plot(NA, ylim=c(0, 1), xlim=c(1, 7), ylab='hits - false alarms', xlab='set size', main=paste(ifelse(cond == 'sequential', '(B) Sequential', '(A) Simultaneous'), 'Condition'), axes=FALSE)
axis(1, at=c(1:3, 5:7), labels=rep(c(2,4,8), 2), mgp=c(1, 1, 0))
axis(2, at=seq(0, 1, .1), labels=seq(0, 1, .1))
abline(h=seq(0, 1, .1), col='gray', lty=2)
# one line per pp
for(s in unique(combinedDat$sub)) {
y1 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'articulate' & combinedDat$seq == cond]
y2 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'silent' & combinedDat$seq == cond]
lines(x=c(1:3), y=y1, col='#00000022')
lines(x=c(5:7), y=y2, col='#00000022')
points(x=c(1:3, 5:7), y=c(y1, y2), col='#00000055', pch=19)
}
# group means as symbols
gM <- aggregate(d ~ ss + seq + art, combinedDat, mean)
gM <- gM$d[gM$seq == cond]
lines(x=c(1:3), y=gM[1:3], col='#000000', lwd=2)
lines(x=c(5:7), y=gM[4:6], col='#000000', lwd=2)
points(x=c(1:3, 5:7), y=gM, col=rep(c('#FF0000', '#0000FF'), each=3), pch=rep(c(17, 15), each=3), cex=1.8)
# add a legend
legend(x=3.75, y=.15, legend=c('articulate', 'silent'), col=c('#FF0000', '#0000FF'), pch=c(17,15), bty='n')
}
# Descriptive Statistics for the STA Paper
# f.sense@rug.nl | Sept. '13
# Assumes that `combinedDat` is loaded into the environment (created in supplement.Rmd)
subj <- unique(combinedDat$sub)
# Plotting parameters:
pdf('~/Desktop/descriptiveStats.pdf', width = 11, height = 5)
par(mfrow = c( 1, 2), las=1)
for(cond in c('simultaneous', 'sequential')) {
plot(NA, ylim=c(0, 1), xlim=c(1, 7), ylab='hits - false alarms', xlab='set size', main=paste(ifelse(cond == 'sequential', '(B) Sequential', '(A) Simultaneous'), 'Condition'), axes=FALSE)
axis(1, at=c(1:3, 5:7), labels=rep(c(2,4,8), 2), mgp=c(1, 1, 0))
axis(2, at=seq(0, 1, .1), labels=seq(0, 1, .1))
abline(h=seq(0, 1, .1), col='gray', lty=2)
# one line per pp
for(s in unique(combinedDat$sub)) {
y1 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'articulate' & combinedDat$seq == cond]
y2 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'silent' & combinedDat$seq == cond]
lines(x=c(1:3), y=y1, col='#00000022')
lines(x=c(5:7), y=y2, col='#00000022')
points(x=c(1:3, 5:7), y=c(y1, y2), col='#00000055', pch=19)
}
# group means as symbols
gM <- aggregate(d ~ ss + seq + art, combinedDat, mean)
gM <- gM$d[gM$seq == cond]
lines(x=c(1:3), y=gM[1:3], col='#000000', lwd=2)
lines(x=c(5:7), y=gM[4:6], col='#000000', lwd=2)
points(x=c(1:3, 5:7), y=gM, col=rep(c('#FF0000', '#0000FF'), each=3), pch=rep(c(17, 15), each=3), cex=1.8)
# add a legend
legend(x=3.75, y=.15, legend=c('articulate', 'silent'), col=c('#FF0000', '#0000FF'), pch=c(17,15), bty='n')
}
# par(mfrow = c( 1, 2))
# #par(mgp = c(3, 1, 0))  # The default is c(3, 1, 0)
# par(las=1)
#
# for(cond in c('simultaneous', 'sequential')) {
#
#   plot(NA, ylim=c(.475, 1), xlim=c(1, 7), ylab='Mean Accuracy', xlab='set size', main=paste(ifelse(cond == 'sequential', '(B) Sequential', '(A) Simultaneous'), 'Condition'), axes=FALSE)
#   #axis(1, at=c(1:3, 5:7), labels=paste(rep(c(2,4,8), times=2)))
#   axis(1, at=c(1:3, 5:7), labels=rep(c(2,4,8), 2), mgp=c(1, 1, 0))
#   axis(2, at=seq(.5, 1, .1), labels=seq(.5, 1, .1))
#   abline(h=seq(.5, 1, .1), col='gray', lty=2)
#
#   # one line per pp
#   for(s in subj) {
#     y1 <- combinedDat$phat[combinedDat$sub == s & combinedDat$art == 'articulate' & combinedDat$seq == cond]
#     y2 <- combinedDat$phat[combinedDat$sub == s & combinedDat$art == 'silent' & combinedDat$seq == cond]
# #     lines(x=c(1:3, 5:7), y=c(y1, y2), col='#00000022')
#     lines(x=c(1:3), y=y1, col='#00000022')
#     lines(x=c(5:7), y=y2, col='#00000022')
#     points(x=c(1:3, 5:7), y=c(y1, y2), col='#00000055', pch=19)
#   }
#
#   # group means as symbols
#   gM <- aggregate(phat ~ ss + seq + art, combinedDat, mean)
#   gM <- gM$phat[gM$seq == cond]
# #   lines(x=c(1:3, 5:7), y=gM, col='#000000', lwd=2)
#   lines(x=c(1:3), y=gM[1:3], col='#000000', lwd=2)
#   lines(x=c(5:7), y=gM[4:6], col='#000000', lwd=2)
#   points(x=c(1:3, 5:7), y=gM, col=rep(c('#FF0000', '#0000FF'), each=3), pch=rep(c(17, 15), each=3), cex=1.8)
#
#   # add a legend
#   legend(x=4, y=.59, legend=c('articulate', 'silent'), col=c('#FF0000', '#0000FF'), pch=c(17,15), bty='n')
# }
dev.off()
setwd("~/Dropbox/statetrace/paper/figures")
# Descriptive Statistics Plot for the STA Paper
# f.sense@rug.nl | Sept. '13
# Assumes that `combinedDat` is loaded into the environment (created in supplement.Rmd).
subj <- unique(combinedDat$sub)
# Plotting parameters:
pdf('descriptiveStats.pdf', width = 11, height = 5)
par(mfrow = c( 1, 2), las=1)
for(cond in c('simultaneous', 'sequential')) {
plot(NA, ylim=c(0, 1), xlim=c(1, 7), ylab='hits - false alarms', xlab='set size', main=paste(ifelse(cond == 'sequential', '(B) Sequential', '(A) Simultaneous'), 'Condition'), axes=FALSE)
axis(1, at=c(1:3, 5:7), labels=rep(c(2,4,8), 2), mgp=c(1, 1, 0))
axis(2, at=seq(0, 1, .1), labels=seq(0, 1, .1))
abline(h=seq(0, 1, .1), col='gray', lty=2)
# one line per pp
for(s in unique(combinedDat$sub)) {
y1 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'articulate' & combinedDat$seq == cond]
y2 <- combinedDat$d[combinedDat$sub == s & combinedDat$art == 'silent' & combinedDat$seq == cond]
lines(x=c(1:3), y=y1, col='#00000022')
lines(x=c(5:7), y=y2, col='#00000022')
points(x=c(1:3, 5:7), y=c(y1, y2), col='#00000055', pch=19)
}
# group means as symbols
gM <- aggregate(d ~ ss + seq + art, combinedDat, mean)
gM <- gM$d[gM$seq == cond]
lines(x=c(1:3), y=gM[1:3], col='#000000', lwd=2)
lines(x=c(5:7), y=gM[4:6], col='#000000', lwd=2)
points(x=c(1:3, 5:7), y=gM, col=rep(c('#FF0000', '#0000FF'), each=3), pch=rep(c(17, 15), each=3), cex=1.8)
# add a legend
legend(x=3.75, y=.15, legend=c('articulate', 'silent'), col=c('#FF0000', '#0000FF'), pch=c(17,15), bty='n')
}
dev.off()
